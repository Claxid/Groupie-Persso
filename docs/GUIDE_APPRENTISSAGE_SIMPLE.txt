================================================================================
    GUIDE SUPER SIMPLE - COMPRENDRE GROUPIE TRACKERS LIGNE PAR LIGNE
================================================================================

ðŸ“– TABLE DES MATIÃˆRES
==================
1. C'est quoi ce projet ? (Explication ultra simple)
2. Le serveur Go expliquÃ© ligne par ligne
3. Le JavaScript expliquÃ© ligne par ligne
4. Comment tout fonctionne ensemble


================================================================================
PARTIE 1 : C'EST QUOI CE PROJET ? ðŸŽµ
================================================================================

IMAGINE UN MAGASIN DE DISQUES VINYLES
--------------------------------------

Tu as un site web qui montre des vinyles d'artistes.
Quand tu passes la souris sur un vinyle â†’ il tourne et joue de la musique
Quand tu cliques â†’ tu vois les infos de l'artiste (membres, dates, lieux)


MAIS D'OÃ™ VIENNENT LES DONNÃ‰ES ?
---------------------------------

Les infos des artistes sont sur un AUTRE SITE (une API externe)
â†’ Comme si les infos Ã©taient dans un autre magasin

PROBLÃˆME : Ton navigateur (Chrome, Firefox) refuse d'aller chercher lÃ -bas
â†’ C'est une rÃ¨gle de sÃ©curitÃ© appelÃ©e "CORS"

SOLUTION : On crÃ©e un SERVEUR GO qui joue le rÃ´le de "livreur"
â†’ Il va chercher les infos pour toi et te les donne


ANALOGIE SIMPLE
---------------

TOI (navigateur)  â†’  demande Ã   â†’  SERVEUR GO  â†’  qui demande Ã   â†’  API EXTERNE
                                      â†“
                                  renvoie tout
                                      â†“
TOI (navigateur)  â†  reÃ§oit les donnÃ©es

C'est comme commander sur Amazon : tu ne vas pas chercher toi-mÃªme au dÃ©pÃ´t,
Amazon livre pour toi !


LES FICHIERS DU PROJET
-----------------------

main.go              â†’ Le "livreur" qui rÃ©cupÃ¨re les donnÃ©es
index.html           â†’ La page que tu vois dans le navigateur
ui.js                â†’ Le code qui fait tourner les vinyles
search.js            â†’ Le code qui permet de chercher un artiste
geoloc.js            â†’ Le code qui affiche la carte avec les concerts
style.css            â†’ Le code qui rend tout joli (couleurs, formes)


================================================================================
PARTIE 2 : LE SERVEUR GO (main.go) - LIGNE PAR LIGNE ðŸš€
================================================================================

ON VA DÃ‰CORTIQUER LA FONCTION LA PLUS IMPORTANTE : proxyAPI()


Ã‰TAPE 1 : LA DÃ‰FINITION DE LA FONCTION
---------------------------------------

func proxyAPI(targetURL string) http.HandlerFunc {

TRADUCTION EN FRANÃ‡AIS :
â†’ "func" = je crÃ©e une fonction
â†’ "proxyAPI" = son nom est "proxyAPI"
â†’ "(targetURL string)" = elle prend un paramÃ¨tre appelÃ© "targetURL" qui est du texte
â†’ "http.HandlerFunc" = elle retourne une fonction qui gÃ¨re des requÃªtes HTTP

ANALOGIE :
C'est comme dire "Je crÃ©e une recette de cuisine appelÃ©e 'faire un gÃ¢teau',
qui prend comme ingrÃ©dient 'type de farine', et qui retourne les instructions"


Ã‰TAPE 2 : RETOURNER UNE FONCTION
---------------------------------

    return func(w http.ResponseWriter, r *http.Request) {

TRADUCTION :
â†’ "return func" = je retourne une nouvelle fonction
â†’ "w http.ResponseWriter" = "w" est l'outil pour Ã©crire la rÃ©ponse au navigateur
â†’ "r *http.Request" = "r" contient les infos de la demande du navigateur

ANALOGIE :
"w" = ton stylo pour Ã©crire une lettre de rÃ©ponse
"r" = la lettre que tu as reÃ§ue avec la question


Ã‰TAPE 3 : ALLER CHERCHER LES DONNÃ‰ES
-------------------------------------

        resp, err := http.Get(targetURL)

TRADUCTION LIGNE PAR LIGNE :
â†’ "resp" = la rÃ©ponse qu'on va recevoir
â†’ "err" = si quelque chose se passe mal, l'erreur sera ici
â†’ ":=" = crÃ©er une nouvelle variable et lui donner une valeur
â†’ "http.Get(targetURL)" = faire une demande GET vers l'URL qu'on a donnÃ©e

ANALOGIE :
Tu appelles un ami au tÃ©lÃ©phone (http.Get)
â†’ "resp" = ce qu'il te rÃ©pond
â†’ "err" = s'il ne rÃ©pond pas ou si la ligne coupe


Ã‰TAPE 4 : VÃ‰RIFIER S'IL Y A UNE ERREUR
---------------------------------------

        if err != nil {
            http.Error(w, "API unavailable", http.StatusServiceUnavailable)
            return
        }

TRADUCTION LIGNE PAR LIGNE :
â†’ "if err != nil" = si "err" n'est PAS vide (donc il y a une erreur)
â†’ "http.Error(w, ...)" = Ã©crire un message d'erreur au navigateur
â†’ "API unavailable" = le message d'erreur
â†’ "http.StatusServiceUnavailable" = code d'erreur 503
â†’ "return" = arrÃªter la fonction ici

ANALOGIE :
Si ton ami ne rÃ©pond pas au tÃ©lÃ©phone,
tu dis Ã  la personne qui t'a demandÃ© d'appeler :
"DÃ©solÃ©, il n'est pas disponible"


Ã‰TAPE 5 : FERMER LA CONNEXION PROPREMENT
-----------------------------------------

        defer resp.Body.Close()

TRADUCTION :
â†’ "defer" = "attends de faire Ã§a Ã  la fin"
â†’ "resp.Body.Close()" = fermer la connexion

ANALOGIE :
Comme quand tu dis "n'oublie pas de fermer la porte en partant"
Le "defer" garantit que la porte sera fermÃ©e, peu importe ce qui se passe


Ã‰TAPE 6 : COPIER LES INFORMATIONS (HEADERS)
--------------------------------------------

        for key, values := range resp.Header {
            for _, value := range values {
                w.Header().Add(key, value)
            }
        }

TRADUCTION LIGNE PAR LIGNE :
â†’ "for key, values := range resp.Header" = pour chaque information dans la rÃ©ponse
â†’ "key" = le nom de l'info (exemple : "Content-Type")
â†’ "values" = les valeurs associÃ©es
â†’ "for _, value := range values" = pour chaque valeur
â†’ "w.Header().Add(key, value)" = ajouter cette info Ã  notre rÃ©ponse

ANALOGIE :
Tu reÃ§ois un colis avec des Ã©tiquettes dessus
Tu copies toutes les Ã©tiquettes sur le nouveau colis que tu vas envoyer
Exemples d'Ã©tiquettes : "Fragile", "Urgent", "Poids: 2kg"


Ã‰TAPE 7 : AJOUTER LA PERMISSION CORS
-------------------------------------

        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Content-Type", "application/json")

TRADUCTION :
â†’ "w.Header().Set(...)" = dÃ©finir une information dans la rÃ©ponse
â†’ "Access-Control-Allow-Origin", "*" = autoriser TOUS les sites Ã  lire cette rÃ©ponse
â†’ "Content-Type", "application/json" = le contenu est du format JSON

ANALOGIE :
Sur ton colis, tu ajoutes une Ã©tiquette spÃ©ciale qui dit :
"Tout le monde peut ouvrir ce colis" (Access-Control-Allow-Origin)
"Contenu : donnÃ©es JSON" (Content-Type)


Ã‰TAPE 8 : COPIER LE CONTENU
----------------------------

        w.WriteHeader(resp.StatusCode)
        io.Copy(w, resp.Body)

TRADUCTION :
â†’ "w.WriteHeader(resp.StatusCode)" = copier le code de statut (200 OK, 404 Not Found, etc.)
â†’ "io.Copy(w, resp.Body)" = copier tout le contenu de la rÃ©ponse

ANALOGIE :
Tu Ã©cris sur l'enveloppe : "Statut : OK" (ou "Erreur")
Puis tu copies le contenu de la lettre que tu as reÃ§ue dans ta nouvelle lettre


RÃ‰SUMÃ‰ DE TOUTE LA FONCTION proxyAPI
-------------------------------------

EN 8 Ã‰TAPES SIMPLES :
1. On dÃ©finit une fonction qui prend une URL
2. On retourne une fonction qui va gÃ©rer les requÃªtes
3. On va chercher les donnÃ©es Ã  l'URL donnÃ©e
4. Si erreur â†’ on dit "pas dispo" et on arrÃªte
5. On prÃ©pare la fermeture de la connexion
6. On copie toutes les infos (headers) de la rÃ©ponse
7. On ajoute la permission CORS (pour Ã©viter les blocages)
8. On copie le contenu JSON et on l'envoie au navigateur

SCHÃ‰MA ASCII :

Navigateur  â†’  [Demande /api/artists-proxy]  â†’  Serveur Go
                                                      â†“
                                           [http.Get vers API externe]
                                                      â†“
                                           [ReÃ§oit JSON des artistes]
                                                      â†“
                                           [Ajoute header CORS]
                                                      â†“
Navigateur  â†  [ReÃ§oit JSON sans blocage]  â†  Serveur Go

func proxyAPI(targetURL string) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 1. Faire une requÃªte GET vers l'API externe
        resp, err := http.Get(targetURL)
        
        // 2. Si erreur, renvoyer code 503
        if err != nil {
            http.Error(w, "API unavailable", http.StatusServiceUnavailable)
            return
        }
        defer resp.Body.Close()
        
        // 3. Copier les headers de l'API vers notre rÃ©ponse
        for key, values := range resp.Header {
            for _, value := range values {
                w.Header().Add(key, value)
            }
        }
        
        // 4. IMPORTANT : Ajouter le header CORS pour autoriser tous les domaines
