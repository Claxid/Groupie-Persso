================================================================================
    GUIDE SUPER SIMPLE - COMPRENDRE GROUPIE TRACKERS LIGNE PAR LIGNE
================================================================================

üìñ TABLE DES MATI√àRES
==================
1. C'est quoi ce projet ? (Explication ultra simple)
2. Le serveur Go expliqu√© ligne par ligne
3. Le JavaScript expliqu√© ligne par ligne
4. Comment tout fonctionne ensemble


================================================================================
PARTIE 1 : C'EST QUOI CE PROJET ? üéµ
================================================================================

IMAGINE UN MAGASIN DE DISQUES VINYLES
--------------------------------------

Tu as un site web qui montre des vinyles d'artistes.
Quand tu passes la souris sur un vinyle ‚Üí il tourne et joue de la musique
Quand tu cliques ‚Üí tu vois les infos de l'artiste (membres, dates, lieux)


MAIS D'O√ô VIENNENT LES DONN√âES ?
---------------------------------

Les infos des artistes sont sur un AUTRE SITE (une API externe)
‚Üí Comme si les infos √©taient dans un autre magasin

PROBL√àME : Ton navigateur (Chrome, Firefox) refuse d'aller chercher l√†-bas
‚Üí C'est une r√®gle de s√©curit√© appel√©e "CORS"

SOLUTION : On cr√©e un SERVEUR GO qui joue le r√¥le de "livreur"
‚Üí Il va chercher les infos pour toi et te les donne


ANALOGIE SIMPLE
---------------

TOI (navigateur)  ‚Üí  demande √†  ‚Üí  SERVEUR GO  ‚Üí  qui demande √†  ‚Üí  API EXTERNE
                                      ‚Üì
                                  renvoie tout
                                      ‚Üì
TOI (navigateur)  ‚Üê  re√ßoit les donn√©es

C'est comme commander sur Amazon : tu ne vas pas chercher toi-m√™me au d√©p√¥t,
Amazon livre pour toi !


LES FICHIERS DU PROJET
-----------------------

main.go              ‚Üí Le "livreur" qui r√©cup√®re les donn√©es
index.html           ‚Üí La page que tu vois dans le navigateur
ui.js                ‚Üí Le code qui fait tourner les vinyles
search.js            ‚Üí Le code qui permet de chercher un artiste
geoloc.js            ‚Üí Le code qui affiche la carte avec les concerts
style.css            ‚Üí Le code qui rend tout joli (couleurs, formes)


================================================================================
PARTIE 2 : LE SERVEUR GO (main.go) - LIGNE PAR LIGNE üöÄ
================================================================================

ON VA D√âCORTIQUER LA FONCTION LA PLUS IMPORTANTE : proxyAPI()


√âTAPE 1 : LA D√âFINITION DE LA FONCTION
---------------------------------------

func proxyAPI(targetURL string) http.HandlerFunc {

TRADUCTION EN FRAN√áAIS :
‚Üí "func" = je cr√©e une fonction
‚Üí "proxyAPI" = son nom est "proxyAPI"
‚Üí "(targetURL string)" = elle prend un param√®tre appel√© "targetURL" qui est du texte
‚Üí "http.HandlerFunc" = elle retourne une fonction qui g√®re des requ√™tes HTTP

ANALOGIE :
C'est comme dire "Je cr√©e une recette de cuisine appel√©e 'faire un g√¢teau',
qui prend comme ingr√©dient 'type de farine', et qui retourne les instructions"


√âTAPE 2 : RETOURNER UNE FONCTION
---------------------------------

    return func(w http.ResponseWriter, r *http.Request) {

TRADUCTION :
‚Üí "return func" = je retourne une nouvelle fonction
‚Üí "w http.ResponseWriter" = "w" est l'outil pour √©crire la r√©ponse au navigateur
‚Üí "r *http.Request" = "r" contient les infos de la demande du navigateur

ANALOGIE :
"w" = ton stylo pour √©crire une lettre de r√©ponse
"r" = la lettre que tu as re√ßue avec la question


√âTAPE 3 : ALLER CHERCHER LES DONN√âES
-------------------------------------

        resp, err := http.Get(targetURL)

TRADUCTION LIGNE PAR LIGNE :
‚Üí "resp" = la r√©ponse qu'on va recevoir
‚Üí "err" = si quelque chose se passe mal, l'erreur sera ici
‚Üí ":=" = cr√©er une nouvelle variable et lui donner une valeur
‚Üí "http.Get(targetURL)" = faire une demande GET vers l'URL qu'on a donn√©e

ANALOGIE :
Tu appelles un ami au t√©l√©phone (http.Get)
‚Üí "resp" = ce qu'il te r√©pond
‚Üí "err" = s'il ne r√©pond pas ou si la ligne coupe


√âTAPE 4 : V√âRIFIER S'IL Y A UNE ERREUR
---------------------------------------

        if err != nil {
            http.Error(w, "API unavailable", http.StatusServiceUnavailable)
            return
        }

TRADUCTION LIGNE PAR LIGNE :
‚Üí "if err != nil" = si "err" n'est PAS vide (donc il y a une erreur)
‚Üí "http.Error(w, ...)" = √©crire un message d'erreur au navigateur
‚Üí "API unavailable" = le message d'erreur
‚Üí "http.StatusServiceUnavailable" = code d'erreur 503
‚Üí "return" = arr√™ter la fonction ici

ANALOGIE :
Si ton ami ne r√©pond pas au t√©l√©phone,
tu dis √† la personne qui t'a demand√© d'appeler :
"D√©sol√©, il n'est pas disponible"


√âTAPE 5 : FERMER LA CONNEXION PROPREMENT
-----------------------------------------

        defer resp.Body.Close()

TRADUCTION :
‚Üí "defer" = "attends de faire √ßa √† la fin"
‚Üí "resp.Body.Close()" = fermer la connexion

ANALOGIE :
Comme quand tu dis "n'oublie pas de fermer la porte en partant"
Le "defer" garantit que la porte sera ferm√©e, peu importe ce qui se passe


√âTAPE 6 : COPIER LES INFORMATIONS (HEADERS)
--------------------------------------------

        for key, values := range resp.Header {
            for _, value := range values {
                w.Header().Add(key, value)
            }
        }

TRADUCTION LIGNE PAR LIGNE :
‚Üí "for key, values := range resp.Header" = pour chaque information dans la r√©ponse
‚Üí "key" = le nom de l'info (exemple : "Content-Type")
‚Üí "values" = les valeurs associ√©es
‚Üí "for _, value := range values" = pour chaque valeur
‚Üí "w.Header().Add(key, value)" = ajouter cette info √† notre r√©ponse

ANALOGIE :
Tu re√ßois un colis avec des √©tiquettes dessus
Tu copies toutes les √©tiquettes sur le nouveau colis que tu vas envoyer
Exemples d'√©tiquettes : "Fragile", "Urgent", "Poids: 2kg"


√âTAPE 7 : AJOUTER LA PERMISSION CORS
-------------------------------------

        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Content-Type", "application/json")

TRADUCTION :
‚Üí "w.Header().Set(...)" = d√©finir une information dans la r√©ponse
‚Üí "Access-Control-Allow-Origin", "*" = autoriser TOUS les sites √† lire cette r√©ponse
‚Üí "Content-Type", "application/json" = le contenu est du format JSON

ANALOGIE :
Sur ton colis, tu ajoutes une √©tiquette sp√©ciale qui dit :
"Tout le monde peut ouvrir ce colis" (Access-Control-Allow-Origin)
"Contenu : donn√©es JSON" (Content-Type)


√âTAPE 8 : COPIER LE CONTENU
----------------------------

        w.WriteHeader(resp.StatusCode)
        io.Copy(w, resp.Body)

TRADUCTION :
‚Üí "w.WriteHeader(resp.StatusCode)" = copier le code de statut (200 OK, 404 Not Found, etc.)
‚Üí "io.Copy(w, resp.Body)" = copier tout le contenu de la r√©ponse

ANALOGIE :
Tu √©cris sur l'enveloppe : "Statut : OK" (ou "Erreur")
Puis tu copies le contenu de la lettre que tu as re√ßue dans ta nouvelle lettre


R√âSUM√â DE TOUTE LA FONCTION proxyAPI
-------------------------------------

EN 8 √âTAPES SIMPLES :
1. On d√©finit une fonction qui prend une URL
2. On retourne une fonction qui va g√©rer les requ√™tes
3. On va chercher les donn√©es √† l'URL donn√©e
4. Si erreur ‚Üí on dit "pas dispo" et on arr√™te
5. On pr√©pare la fermeture de la connexion
6. On copie toutes les infos (headers) de la r√©ponse
7. On ajoute la permission CORS (pour √©viter les blocages)
8. On copie le contenu JSON et on l'envoie au navigateur

SCH√âMA ASCII :

Navigateur  ‚Üí  [Demande /api/artists-proxy]  ‚Üí  Serveur Go
                                                      ‚Üì
                                           [http.Get vers API externe]
                                                      ‚Üì
                                           [Re√ßoit JSON des artistes]
                                                      ‚Üì
                                           [Ajoute header CORS]
                                                      ‚Üì
Navigateur  ‚Üê  [Re√ßoit JSON sans blocage]  ‚Üê  Serveur Go

func proxyAPI(targetURL string) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 1. Faire une requ√™te GET vers l'API externe
        resp, err := http.Get(targetURL)
        
        // 2. Si erreur, renvoyer code 503
        if err != nil {
            http.Error(w, "API unavailable", http.StatusServiceUnavailable)
            return
        }
        defer resp.Body.Close()
        
        // 3. Copier les headers de l'API vers notre r√©ponse
        for key, values := range resp.Header {
            for _, value := range values {
                w.Header().Add(key, value)
            }
        }
        
        // 4. IMPORTANT : Ajouter le header CORS pour autoriser tous les domaines
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Content-Type", "application/json")
        
        // 5. Copier le statut HTTP et le contenu JSON
        w.WriteHeader(resp.StatusCode)
        io.Copy(w, resp.Body)
    }
}

EXPLICATION SIMPLE :
- targetURL = URL de l'API externe (ex: https://groupietrackers.../api/artists)
- http.HandlerFunc = fonction qui traite une requ√™te HTTP
- Le proxy agit comme un "interm√©diaire" entre le navigateur et l'API externe
- Il ajoute "Access-Control-Allow-Origin: *" pour autoriser le JavaScript

B) ROUTES PROXY API
-------------------

// Route pour r√©cup√©rer la liste des artistes
http.HandleFunc("/api/artists-proxy", 
    proxyAPI("https://groupietrackers.herokuapp.com/api/artists"))

COMMENT √áA MARCHE ?
1. Le JavaScript fait : fetch('/api/artists-proxy')
2. Le serveur Go re√ßoit la requ√™te
3. Go fait une vraie requ√™te vers l'API externe
4. Go renvoie le JSON au JavaScript
5. JavaScript peut l'utiliser sans erreur CORS

C) ROUTE AUDIO PROXY - CAS SP√âCIAL
-----------------------------------

http.HandleFunc("/api/audio-proxy", func(w http.ResponseWriter, r *http.Request) {
    // 1. R√©cup√©rer l'URL de l'audio depuis le param√®tre ?url=...
    url := r.URL.Query().Get("url")
    if url == "" {
        http.Error(w, "missing url", http.StatusBadRequest)
        return
    }
    
    // 2. Cr√©er une requ√™te avec un User-Agent (certaines APIs l'exigent)
    req, _ := http.NewRequest(http.MethodGet, url, nil)
    req.Header.Set("User-Agent", "Mozilla/5.0 (compatible; GroupieProxy/1.0)")
    
    // 3. Faire la requ√™te et copier l'audio
    resp, _ := http.DefaultClient.Do(req)
    defer resp.Body.Close()
    
    // 4. D√©finir le type de contenu (audio MP3)
    w.Header().Set("Content-Type", "audio/mpeg")
    w.Header().Set("Access-Control-Allow-Origin", "*")
    w.WriteHeader(resp.StatusCode)
    io.Copy(w, resp.Body)
})

POURQUOI CE PROXY AUDIO ?
- iTunes/Deezer bloquent les requ√™tes directes depuis le navigateur
- Le proxy Go se fait passer pour un navigateur (User-Agent)
- Le navigateur peut ensuite lire l'audio sans blocage

D) ROUTES HTML - SERVIR LES FICHIERS
-------------------------------------

// Page d'accueil
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path != "/" {
        http.NotFound(w, r)
        return
    }
    http.ServeFile(w, r, "index.html")
})

// Fichiers statiques (CSS, JS, images)
fs := http.FileServer(http.Dir(filepath.Join("web", "static")))
http.Handle("/static/", http.StripPrefix("/static/", fs))

EXPLICATION :
- http.ServeFile = envoyer un fichier HTML au navigateur
- http.FileServer = servir tout un dossier de fichiers
- StripPrefix = retirer "/static/" du chemin pour chercher dans "web/static/"


================================================================================
PARTIE 3 : FRONTEND JAVASCRIPT - ARCHITECTURE (15 MIN)
================================================================================

FICHIER : web/static/js/ui.js (1255 lignes)
--------------------------------------------

A) MODULE 1 : NAVIGATION MOBILE (lignes 1-150)
-----------------------------------------------

CONCEPT : Menu hamburger qui appara√Æt sur mobile (<700px)

// 1. Cr√©er le bouton hamburger dynamiquement
var toggle = document.createElement('button');
toggle.id = 'menuToggle';
toggle.textContent = '\u2630'; // ‚ò∞ (ic√¥ne hamburger)
toggle.setAttribute('aria-expanded','false'); // Accessibilit√©

// 2. Fonction qui adapte l'affichage selon la taille d'√©cran
function updateNavVisibility() {
    if (window.innerWidth < 700) {
        // MOBILE : cacher le menu par d√©faut
        nav.style.display = 'none';
    } else {
        // DESKTOP : afficher le menu en horizontal
        nav.style.display = 'flex';
    }
}

// 3. Basculer l'√©tat du menu au clic
toggle.addEventListener('click', function () {
    var showing = nav.style.display !== 'none';
    if (showing) {
        nav.style.display = 'none'; // Fermer
        toggle.setAttribute('aria-expanded','false');
    } else {
        nav.style.display = 'flex'; // Ouvrir
        toggle.setAttribute('aria-expanded','true');
    }
});

POINTS CL√âS :
- window.innerWidth = largeur de la fen√™tre en pixels
- aria-expanded = attribut pour les lecteurs d'√©cran (accessibilit√©)
- addEventListener('click') = d√©tecter un clic
- display: 'none' = cacher, display: 'flex' = afficher

B) MODULE 2 : VINYLES ANIM√âS (lignes 151-1050)
-----------------------------------------------

CONCEPT : Charger des artistes et les afficher sous forme de vinyles cliquables

√âTAPE 1 : CHARGER LES DONN√âES
------------------------------

async function fetchArtists() {
    // Helper pour fetch JSON avec v√©rification erreur
    async function fetchJson(url) {
        const res = await fetch(url, {cache: 'no-store'});
        if (!res.ok) throw new Error('API response ' + res.status);
        return res.json();
    }
    
    let data;
    try {
        // Essayer le proxy local en premier
        data = await fetchJson('/api/artists-proxy');
    } catch (err) {
        // Si √©chec, essayer l'API distante directement
        try {
            data = await fetchJson('https://groupietrackers.herokuapp.com/api/artists');
        } catch (fallbackErr) {
            // Si double √©chec, utiliser des artistes de d√©mo
            return SAMPLE_ARTISTS;
        }
    }
    return Array.isArray(data) ? data : (data.artists || []);
}

CONCEPTS :
- async/await = attendre une r√©ponse asynchrone
- fetch() = faire une requ√™te HTTP
- res.json() = convertir la r√©ponse en objet JavaScript
- try/catch = g√©rer les erreurs
- Fallback = solution de secours

√âTAPE 2 : CR√âER UNE CARTE VINYLE
---------------------------------

function createVinylCard(artist) {
    // 1. Cr√©er le conteneur principal
    const card = document.createElement('div');
    card.className = 'vinyl-card';
    
    // 2. Cr√©er le cadre du vinyle
    const frame = document.createElement('div');
    frame.className = 'vinyl-frame';
    frame.dataset.artistId = artist.id;
    
    // 3. Ajouter l'image de l'artiste
    const cover = document.createElement('img');
    cover.src = artist.image || '/static/images/vinyle.png';
    cover.alt = artist.name;
    cover.className = 'vinyl-cover';
    
    // 4. Cr√©er le disque vinyle (animation rotation)
    const disc = document.createElement('div');
    disc.className = 'vinyl-disc';
    disc.textContent = 'üéµ';
    
    // 5. Assembler les √©l√©ments
    frame.appendChild(cover);
    frame.appendChild(disc);
    card.appendChild(frame);
    
    // 6. √âV√âNEMENT SURVOL : Jouer l'audio
    frame.addEventListener('mouseenter', () => {
        frame.classList.add('playing'); // Ajoute animation CSS
        playArtistPreview(artist.id, artist.name);
    });
    
    frame.addEventListener('mouseleave', () => {
        frame.classList.remove('playing'); // Retire animation
        if (currentAudio) currentAudio.pause();
    });
    
    // 7. √âV√âNEMENT CLIC : Ouvrir le modal
    card.addEventListener('click', () => {
        showArtistModal(artist);
    });
    
    return card;
}

CONCEPTS :
- document.createElement('div') = cr√©er un √©l√©ment HTML
- element.className = d√©finir une classe CSS
- dataset.artistId = attribut data-* personnalis√©
- appendChild() = ajouter un √©l√©ment enfant
- addEventListener('mouseenter') = d√©tecter le survol
- classList.add('playing') = ajouter une classe CSS (animation)

√âTAPE 3 : JOUER UN APER√áU AUDIO
--------------------------------

async function playArtistPreview(artistId, artistName) {
    // 1. Stopper l'audio pr√©c√©dent (un seul vinyle joue √† la fois)
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
    }
    if (currentFrame) {
        currentFrame.classList.remove('playing');
    }
    
    let previewUrl = null;
    
    // 2. STRAT√âGIE 1 : Chercher sur iTunes
    try {
        const itunesUrl = `https://itunes.apple.com/search?term=${encodeURIComponent(artistName)}&entity=song&limit=1`;
        const res = await fetch(itunesUrl);
        const data = await res.json();
        if (data.results && data.results.length > 0) {
            previewUrl = data.results[0].previewUrl;
        }
    } catch (err) {
        console.log('iTunes search failed, trying Deezer');
    }
    
    // 3. STRAT√âGIE 2 : Si iTunes √©choue, chercher sur Deezer
    if (!previewUrl) {
        try {
            const deezerUrl = `https://api.deezer.com/search?q=${encodeURIComponent(artistName)}&limit=1`;
            const res = await fetch(deezerUrl);
            const data = await res.json();
            if (data.data && data.data.length > 0) {
                previewUrl = data.data[0].preview;
            }
        } catch (err) {
            console.log('Deezer search failed');
        }
    }
    
    // 4. STRAT√âGIE 3 : Si tout √©choue, utiliser un MP3 de secours
    if (!previewUrl) {
        previewUrl = FALLBACK_PREVIEW;
    }
    
    // 5. Utiliser le proxy audio pour √©viter CORS
    const proxiedUrl = `/api/audio-proxy?url=${encodeURIComponent(previewUrl)}`;
    
    // 6. Cr√©er un lecteur audio et jouer
    const audio = new Audio(proxiedUrl);
    audio.volume = 0.3; // Volume √† 30%
    audio.play().catch(err => console.log('Audio play failed:', err));
    
    // 7. M√©moriser l'audio et le frame pour les arr√™ter plus tard
    currentAudio = audio;
    currentFrame = document.querySelector(`.vinyl-frame[data-artist-id="${artistId}"]`);
}

CONCEPTS :
- encodeURIComponent() = encoder une URL (espaces, accents)
- new Audio(url) = cr√©er un lecteur audio
- audio.play() = lancer la lecture
- .catch() = g√©rer les erreurs de Promise
- Proxy audio = passer par le serveur Go pour √©viter CORS


================================================================================
PARTIE 4 : FONCTIONNALIT√âS AVANC√âES (20 MIN)
================================================================================

FICHIER : web/static/js/search.js (420 lignes)
-----------------------------------------------

A) RECHERCHE AVEC SUGGESTIONS EN TEMPS R√âEL
--------------------------------------------

// 1. Charger les donn√©es au premier appel
let allArtists = []; // Cache global
async function ensureData() {
    if (allArtists.length) return allArtists; // D√©j√† charg√©
    
    // Charger depuis le proxy
    const resp = await fetch('/api/artists-proxy');
    const data = await resp.json();
    allArtists = Array.isArray(data) ? data : (data.artists || []);
    return allArtists;
}

// 2. Afficher des suggestions pendant la saisie
function showSuggestions(query) {
    const artists = allArtists.filter(a => 
        (a.name || '').toLowerCase().includes(query.toLowerCase())
    );
    
    // Limiter √† 5 suggestions
    const limited = artists.slice(0, 5);
    
    // Cr√©er les boutons de suggestion
    suggestionsEl.innerHTML = '';
    limited.forEach(artist => {
        const btn = document.createElement('button');
        btn.className = 'suggestion-item';
        btn.textContent = artist.name;
        
        // Clic sur suggestion = remplir le champ et rechercher
        btn.addEventListener('click', () => {
            input.value = artist.name;
            form.dispatchEvent(new Event('submit'));
        });
        
        suggestionsEl.appendChild(btn);
    });
}

// 3. √âcouter la saisie dans le champ de recherche
input.addEventListener('input', () => {
    const val = input.value.trim();
    if (!val) {
        suggestionsEl.innerHTML = ''; // Vider si champ vide
        return;
    }
    showSuggestions(val);
});

CONCEPTS :
- array.filter() = filtrer un tableau selon une condition
- string.toLowerCase() = convertir en minuscules (recherche insensible casse)
- string.includes() = v√©rifier si une cha√Æne contient une autre
- array.slice(0, 5) = extraire les 5 premiers √©l√©ments
- innerHTML = modifier le contenu HTML d'un √©l√©ment
- trim() = retirer les espaces avant/apr√®s

B) FILTRES RAPIDES (CHIPS)
---------------------------

let activeFilter = null; // null = aucun filtre actif

// Fonction qui teste si un artiste correspond au filtre
function filterByBadge(artist, filterId) {
    if (!filterId) return true; // Pas de filtre = tout afficher
    
    const name = (artist.name || '').toLowerCase();
    const creation = Number(artist.creationDate || 0);
    
    switch (filterId) {
        case 'rock':
            // Tester si le nom contient "rock", "metal", "punk", etc.
            return /rock|metal|punk|roll/.test(name);
            
        case 'seventies':
            // Artiste cr√©√© dans les ann√©es 70
            return (creation >= 1970 && creation < 1980);
            
        case 'usa':
            // Tester si la localisation contient "usa", "california", etc.
            const location = (artist.location || '').toLowerCase();
            return /(usa|united states|california)/.test(location);
            
        default:
            return true;
    }
}

// Gestion du clic sur un chip
document.querySelectorAll('.search-filter-chip').forEach(chip => {
    chip.addEventListener('click', () => {
        if (chip.classList.contains('active')) {
            // Si d√©j√† actif, d√©sactiver
            chip.classList.remove('active');
            activeFilter = null;
        } else {
            // Activer ce chip et d√©sactiver les autres
            document.querySelectorAll('.search-filter-chip').forEach(c => 
                c.classList.remove('active')
            );
            chip.classList.add('active');
            activeFilter = chip.dataset.filter;
        }
        
        // Relancer la recherche avec le nouveau filtre
        form.dispatchEvent(new Event('submit'));
    });
});

CONCEPTS :
- Regex /pattern/ = expression r√©guli√®re pour tester un motif
- switch/case = tester plusieurs valeurs possibles
- querySelectorAll() = s√©lectionner tous les √©l√©ments correspondants
- forEach() = boucler sur chaque √©l√©ment
- classList.contains() = v√©rifier si une classe existe
- dataset.filter = lire l'attribut data-filter


FICHIER : web/static/js/geoloc.js (166 lignes)
-----------------------------------------------

A) INITIALISATION DE LA CARTE LEAFLET
--------------------------------------

// 1. Cr√©er une carte centr√©e sur le monde
const map = L.map('map');
map.setView([20, 0], 2); // Latitude 20, Longitude 0, Zoom 2

// 2. Ajouter les tuiles OpenStreetMap (fond de carte)
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors',
    maxZoom: 18,
}).addTo(map);

CONCEPTS :
- L.map('map') = cr√©er une carte Leaflet dans l'√©l√©ment #map
- setView([lat, lon], zoom) = d√©finir la vue initiale
- L.tileLayer() = charger les tuiles de carte (images)
- addTo(map) = ajouter la couche √† la carte

B) G√âOCODAGE AVEC NOMINATIM + CACHE
------------------------------------

// Cache localStorage pour √©viter de g√©ocoder deux fois le m√™me lieu
const cacheKey = (loc) => `geocode:${loc.toLowerCase()}`;

async function geocodeLocation(loc) {
    // 1. V√©rifier si d√©j√† en cache
    const key = cacheKey(loc);
    const cached = localStorage.getItem(key);
    if (cached) {
        try {
            return JSON.parse(cached); // {lat: X, lon: Y}
        } catch {}
    }
    
    // 2. Faire une requ√™te vers Nominatim (g√©ocodeur OpenStreetMap)
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(loc)}`;
    const res = await fetch(url, {
        headers: { 'Accept-Language': 'fr' }, // R√©sultats en fran√ßais
    });
    
    // 3. Parser la r√©ponse
    const arr = await res.json();
    if (!Array.isArray(arr) || arr.length === 0) return null;
    
    // 4. Prendre le premier r√©sultat
    const best = arr[0];
    const point = { lat: parseFloat(best.lat), lon: parseFloat(best.lon) };
    
    // 5. Sauvegarder dans le cache
    localStorage.setItem(key, JSON.stringify(point));
    
    // 6. Attendre 250ms pour respecter la limite de Nominatim (1 req/sec)
    await sleep(250);
    
    return point;
}

CONCEPTS :
- localStorage = stockage persistant dans le navigateur
- JSON.parse() = convertir une cha√Æne JSON en objet
- JSON.stringify() = convertir un objet en cha√Æne JSON
- parseFloat() = convertir une cha√Æne en nombre d√©cimal
- sleep(ms) = attendre un d√©lai (politesse avec l'API)

C) PLACER DES MARQUEURS SUR LA CARTE
-------------------------------------

async function main() {
    // 1. Charger les donn√©es (artistes + relations)
    const { relationByLocation } = await buildData();
    
    const bounds = []; // Pour ajuster la vue
    
    // 2. Pour chaque lieu, g√©ocoder et placer un marqueur
    for (const [loc, bucket] of relationByLocation.entries()) {
        try {
            // G√©ocoder le lieu
            const pt = await geocodeLocation(loc);
            if (!pt) continue; // Pas trouv√©, passer au suivant
            
            // Cr√©er un marqueur Leaflet
            const marker = L.marker([pt.lat, pt.lon]).addTo(map);
            
            // Cr√©er un popup avec HTML personnalis√©
            marker.bindPopup(popupHtml(bucket));
            
            // Ajouter les coordonn√©es pour ajuster la vue
            bounds.push([pt.lat, pt.lon]);
            
        } catch (e) {
            console.error('Failed to geocode:', loc, e);
        }
    }
    
    // 3. Ajuster la vue de la carte pour voir tous les marqueurs
    if (bounds.length) {
        const b = L.latLngBounds(bounds);
        map.fitBounds(b.pad(0.2)); // Padding 20% pour a√©rer
    }
}

CONCEPTS :
- Map.entries() = boucler sur une Map (cl√©, valeur)
- L.marker([lat, lon]) = cr√©er un marqueur
- marker.bindPopup(html) = associer un popup au marqueur
- L.latLngBounds(bounds) = cr√©er une zone englobante
- map.fitBounds() = ajuster la vue pour voir toute la zone


FICHIER : web/static/js/subscription.js (232 lignes)
-----------------------------------------------------

A) VALIDATION DE CARTE BANCAIRE (SIMULATION)
---------------------------------------------

function validateCardNumber(cardNumber) {
    // 1. Nettoyer les espaces et tirets
    const cleaned = cardNumber.replace(/[\s-]/g, '');
    
    // 2. V√©rifier la longueur (13-19 chiffres)
    if (cleaned.length < 13 || cleaned.length > 19) return false;
    
    // 3. V√©rifier que ce sont bien des chiffres
    if (!/^\d+$/.test(cleaned)) return false;
    
    return true;
}

function validateExpiryDate(expiryDate) {
    // Format attendu : MM/YY ou MM/YYYY
    const parts = expiryDate.split('/');
    if (parts.length !== 2) return false;
    
    const month = parseInt(parts[0], 10);
    let year = parseInt(parts[1], 10);
    
    // Convertir YY en YYYY
    if (year < 100) year += 2000;
    
    // V√©rifier mois valide
    if (month < 1 || month > 12) return false;
    
    // V√©rifier que la date n'est pas expir√©e
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth() + 1;
    
    if (year < currentYear) return false;
    if (year === currentYear && month < currentMonth) return false;
    
    return true;
}

CONCEPTS :
- string.replace(/regex/g, '') = remplacer avec regex
- /^\d+$/ = regex qui teste "que des chiffres"
- parseInt(str, 10) = convertir une cha√Æne en nombre entier
- new Date() = obtenir la date actuelle
- getFullYear() = obtenir l'ann√©e (2026)
- getMonth() = obtenir le mois (0-11, donc +1)

B) FORMATAGE AUTOMATIQUE DU NUM√âRO DE CARTE
--------------------------------------------

// √âcouter la saisie dans le champ carte
document.getElementById('cardNumber').addEventListener('input', (e) => {
    let value = e.target.value;
    
    // 1. Retirer tous les espaces
    value = value.replace(/\s/g, '');
    
    // 2. Diviser en groupes de 4 chiffres
    const groups = value.match(/.{1,4}/g);
    
    // 3. Rejoindre avec des espaces
    if (groups) {
        e.target.value = groups.join(' ');
    }
});

EXPLICATION :
- Input : "1234567890123456"
- Apr√®s replace : "1234567890123456"
- Apr√®s match : ["1234", "5678", "9012", "3456"]
- Apr√®s join : "1234 5678 9012 3456"

C) SIMULATION DE PAIEMENT AVEC D√âLAI
-------------------------------------

cardForm.addEventListener('submit', (e) => {
    e.preventDefault();
    
    // 1. Valider les champs
    if (!validateCardNumber(cardNumber)) {
        showError('Num√©ro de carte invalide');
        return;
    }
    
    if (!validateExpiryDate(expiryDate)) {
        showError('Date d\'expiration invalide');
        return;
    }
    
    // 2. Afficher un message de traitement
    showMessage('Traitement en cours...');
    
    // 3. Simuler un d√©lai de traitement (2 secondes)
    setTimeout(() => {
        // 4. Sauvegarder dans localStorage
        localStorage.setItem('subscription', JSON.stringify({
            plan: selectedPlan,
            price: selectedPrice,
            planName: selectedPlanName,
            date: new Date().toISOString()
        }));
        
        // 5. Afficher le message de succ√®s
        showSuccessMessage();
        
        // 6. R√©initialiser le formulaire
        cardForm.reset();
    }, 2000);
});

CONCEPTS :
- e.preventDefault() = emp√™cher le rechargement de page
- setTimeout(callback, ms) = ex√©cuter apr√®s un d√©lai
- toISOString() = convertir Date en format ISO (2026-01-23T14:30:00.000Z)


================================================================================
PARTIE 5 : FLUX DE DONN√âES ET INTERACTIONS (10 MIN)
================================================================================

A) CYCLE DE VIE D'UNE REQU√äTE API
----------------------------------

1. UTILISATEUR charge la page index.html
   ‚Üì
2. NAVIGATEUR t√©l√©charge ui.js
   ‚Üì
3. JAVASCRIPT ex√©cute DOMContentLoaded
   ‚Üì
4. JAVASCRIPT appelle fetchArtists()
   ‚Üì
5. JAVASCRIPT fait : fetch('/api/artists-proxy')
   ‚Üì
6. SERVEUR GO re√ßoit la requ√™te sur /api/artists-proxy
   ‚Üì
7. GO fait : http.Get('https://groupietrackers.herokuapp.com/api/artists')
   ‚Üì
8. API EXTERNE renvoie du JSON √† Go
   ‚Üì
9. GO ajoute les headers CORS et renvoie le JSON au JavaScript
   ‚Üì
10. JAVASCRIPT re√ßoit les donn√©es et cr√©e les vinyles
   ‚Üì
11. NAVIGATEUR affiche les vinyles √† l'utilisateur

B) CYCLE D'INTERACTION UTILISATEUR
-----------------------------------

SC√âNARIO 1 : Survol d'un vinyle
-------------------------------
1. Souris entre dans la zone du vinyle (mouseenter)
2. JavaScript ajoute la classe .playing
3. CSS anime la rotation (keyframes spin)
4. JavaScript appelle playArtistPreview()
5. Recherche iTunes ‚Üí Deezer ‚Üí Fallback
6. JavaScript cr√©e un <audio> et lance play()
7. L'utilisateur entend la musique

SC√âNARIO 2 : Recherche d'un artiste
-----------------------------------
1. Utilisateur tape "Queen" dans le champ
2. JavaScript d√©clenche l'√©v√©nement 'input'
3. showSuggestions() filtre les artistes
4. Affichage de suggestions (Queen, Queensr√øche, etc.)
5. Utilisateur clique sur "Queen"
6. JavaScript remplit le champ et soumet le formulaire
7. renderResults() affiche les r√©sultats filtr√©s
8. Utilisateur clique sur une carte
9. showModal() affiche les d√©tails de l'artiste

SC√âNARIO 3 : G√©olocalisation
----------------------------
1. Utilisateur clique sur "G√©olocalisation"
2. Navigateur charge geoloc.html + geoloc.js
3. JavaScript cr√©e la carte Leaflet
4. buildData() charge artistes + relations
5. Pour chaque lieu :
   a. V√©rifier cache localStorage
   b. Si absent, appeler Nominatim
   c. Sauvegarder les coordonn√©es
   d. Cr√©er un marqueur Leaflet
6. map.fitBounds() ajuste la vue
7. Utilisateur voit tous les concerts sur la carte

C) SYST√àME DE CACHE - OPTIMISATION
-----------------------------------

CACHE 1 : localStorage pour g√©ocodage
-------------------------------------
Cl√© : "geocode:usa-new_york"
Valeur : {"lat":40.7128,"lon":-74.0060}
Dur√©e : Permanent (jusqu'√† effacement manuel)
√âconomie : ~90% des requ√™tes Nominatim

CACHE 2 : Variables globales JavaScript
---------------------------------------
allArtists = [] (search.js)
locationsData = null (ui.js)
datesData = null (ui.js)
relationsData = null (ui.js)
Dur√©e : Pendant la session (rafra√Æchissement page = perte)
√âconomie : √âvite de recharger les donn√©es √† chaque action

CACHE 3 : localStorage pour abonnement
--------------------------------------
Cl√© : "subscription"
Valeur : {"plan":"pro","price":"19.99","date":"2026-01-23T..."}
Dur√©e : Permanent
Utilit√© : Persistance de l'√©tat d'abonnement


================================================================================
R√âSUM√â FINAL - LES 10 CONCEPTS CL√âS √Ä RETENIR
================================================================================

1. PROXY GO = Interm√©diaire pour r√©soudre CORS
   ‚Üí Le serveur Go fait les requ√™tes √† notre place
   ‚Üí Ajoute "Access-Control-Allow-Origin: *"

2. ASYNC/AWAIT = Attendre des r√©ponses asynchrones
   ‚Üí async function = fonction qui peut attendre
   ‚Üí await fetch() = attendre la r√©ponse HTTP
   ‚Üí try/catch = g√©rer les erreurs

3. FETCH API = Faire des requ√™tes HTTP en JavaScript
   ‚Üí fetch(url) = requ√™te GET
   ‚Üí res.json() = parser JSON
   ‚Üí res.ok = v√©rifier statut HTTP

4. DOM MANIPULATION = Cr√©er/modifier HTML avec JavaScript
   ‚Üí document.createElement() = cr√©er √©l√©ment
   ‚Üí element.appendChild() = ajouter enfant
   ‚Üí element.innerHTML = modifier contenu

5. EVENT LISTENERS = R√©agir aux actions utilisateur
   ‚Üí addEventListener('click') = clic souris
   ‚Üí addEventListener('input') = saisie clavier
   ‚Üí addEventListener('mouseenter') = survol

6. CSS CLASSES = Changer l'apparence dynamiquement
   ‚Üí classList.add('playing') = ajouter classe
   ‚Üí classList.remove('playing') = retirer classe
   ‚Üí classList.contains('active') = v√©rifier pr√©sence

7. ARRAY METHODS = Manipuler des listes de donn√©es
   ‚Üí array.filter() = filtrer selon condition
   ‚Üí array.map() = transformer chaque √©l√©ment
   ‚Üí array.forEach() = boucler sur chaque √©l√©ment

8. LOCALSTORAGE = Stockage persistant navigateur
   ‚Üí localStorage.setItem(key, value) = sauvegarder
   ‚Üí localStorage.getItem(key) = r√©cup√©rer
   ‚Üí JSON.stringify() / JSON.parse() = convertir objets

9. REGEX = Tester des motifs dans des cha√Ænes
   ‚Üí /pattern/.test(string) = v√©rifier correspondance
   ‚Üí /rock|metal|punk/ = "ou" logique
   ‚Üí /^\d+$/ = que des chiffres

10. LEAFLET MAP = Cr√©er des cartes interactives
    ‚Üí L.map() = cr√©er carte
    ‚Üí L.marker() = ajouter marqueur
    ‚Üí map.fitBounds() = ajuster vue


